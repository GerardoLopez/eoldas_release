

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>A synthetic experiment: simulating the performance of Sentinel-2 &mdash; EOLDAS Users&#39; Guide 2012.06 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2012.06',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="EOLDAS Users&#39; Guide 2012.06 documentation" href="index.html" />
    <link rel="next" title="Spatial and multi-scale data assimilation examples" href="example_spatial.html" />
    <link rel="prev" title="Radiative transfer modelling for optical remote sensing" href="example2.html" /> 
  </head>
  <body>
      <div class="header">
        <a href="index.html">
          <img class="logo" src="_static/eoldas_logos.png" alt="Logo"/>
        </a>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="example2.html">Radiative transfer modelling for optical remote sensing</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="example_spatial.html">Spatial and multi-scale data assimilation examples</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="a-synthetic-experiment-simulating-the-performance-of-sentinel-2">
<h1>A synthetic experiment: simulating the performance of Sentinel-2<a class="headerlink" href="#a-synthetic-experiment-simulating-the-performance-of-sentinel-2" title="Permalink to this headline">¶</a></h1>
<p>A useful application of the EOLDAS tools is to simulate how different
sensors or combinations of sensors might be expected to work together.
Simply, we could generate a set of artificial observations, acquired
by a sensor (or sensors) from which the spectral, noise and orbital
acquisition characteristics are known (or we can try different set ups
to see their trade offs). We can then use EOLDAS to invert these
synthetic observations and compare to the reality that went into them.
This type of experiments can be very useful to test, for example, the
usefulness of constellation concepts. The current example is a
reduced version of the experiments that are presented in
<a class="reference external" href="http://dx.doi.org/10.1016/j.rse.2011.12.027">Lewis et al (2010)</a>, and
show the use of EOLDAS in simulating ESA&#8217;s upcoming Sentinel-2 performance
for the inversion of biophysical parameters. In this document, we try
to reproduce the middle column in Figure 2 in <a class="reference external" href="http://dx.doi.org/10.1016/j.rse.2011.12.027">Lewis et al (2010)</a></p>
<p>The experiment can be split into a set of simple tasks:</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>We need to generate an appropriate set of observations. On the one hand, this requires</dt>
<dd><ul class="first last simple">
<li>An idea of typical angular sampling.</li>
<li>An idea of the statistics of missing observations due to e.g. cloud.</li>
<li>Trajectories for the land surface parameters.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first"><em>Forward model</em> the land surface parameters to land surface reflectance.</p>
</li>
<li><p class="first">Add noise to the observations</p>
</li>
<li><p class="first">Invert the observations, with whatever prior information might be available.</p>
</li>
</ol>
<p>The first step will require the definition of a typical re-visit schedule
for the sensor, as well as information on illumination geometries. We
make use of the <a class="reference external" href="http://rhodesmill.org/pyephem/">pyephem</a> Python package to
calculate the solar position at a given latitude and longitude. Some
simple rules are given to model the sensor acquisition geometry (for
example, the view zenith angle is assumed to be random). We can use
full wavebands, or just the median wavelength of each band (the latter
is far more efficient, and this solution can be used as a starting
point to solve the full bandpass problem).</p>
<p>A further refinement is the inclusion of missing observations due to
cloud cover, for example. It is typically observed that cloudiness
is correlated in time, so a model of cloudiness that simulates the typical
burst nature of cloud statistics is required. Another way to go about this
is to use long term cloudiness observations, but we choose a very simple
approach in this work.</p>
<p>The parameter trajectories are functions that describe the evolution
of a given parameter in time. In this case, we choose to vary the following
parameters:</p>
<ul class="simple">
<li>LAI</li>
<li>Chlorophyll concentration</li>
<li>Leaf water</li>
<li>Leaf dry matter</li>
<li>Number of leaf layers</li>
<li>First soil component</li>
</ul>
<p>This is an ambitious scenario: the analytic trajectories chosen for these
parameters are smooth, but with very different degrees of smoothness. Some
parameters are set to be constant (leaf layers and leaf dry matter). We
will assume that the regulariser that solves this problem is identical
for all the parameters, and constant in time. Even though we know that
this is not the case, this simplifying assumption still allows the
recovery of reasonable parameter estimates. Note that while in some cases
(such as leaf area index) one might have mechanistic models that maybe
use meteorological inputs to simulate photosynthesis and allocation of
assimilated carbon to the leaves to estimate the amount of leaf area,
for other parameters that have a significant impact on the remote sensing
signal, these models might not be available.</p>
<p>The forward modelling of the parameter trajectories, coupled with the
required wavebands and illumination geometries, produces a set of
synthetic observations: this is what a sensor, operating with the given
characteristics would &#8220;see&#8221;, in terms of surface reflectance. As with
any measurement, noise needs to be incorporated. We do this by adding
some Gaussian noise to the simulated reflectances, in line with what
we expect to be typical values after atmospheric correction. Although
we assume noise to be uncorrelated across bands, in practice it will be.</p>
<p>Finally, we solve the inverse problem: find the parameter trajectories
given the set of noisy and incomplete observations. In reality, we also
need to estimate the strength of the regularisation, a hyperparameter.
In <a class="reference external" href="http://dx.doi.org/10.1016/j.rse.2011.12.027">Lewis et al (2011)</a>
this is done using cross-validation. In the paper, we proceeded as follows:</p>
<ol class="arabic">
<li><p class="first">Set a number of values that <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> might take. This will necessarily be a large range (say from <img class="math" src="_images/math/e32627f389178685006a709382158817d19bacc8.png" alt="10^{-5}-10^{5}"/>), but prior experience might dictate a suitable interval.</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">For one value of <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/>...</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Select one single observation, and remove it from the observations that will go into the inversion</p>
<blockquote>
<div><ol class="arabic simple">
<li>Solve the inverse problem</li>
<li>Predict the missing observation, and compare with the truth</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Calculate a prediction metric, such as root mean square error (RMSE) or similar</p>
</li>
</ol>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Select the value of <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> that results in the most accurate predictions.</p>
</li>
</ol>
<p>This method is clearly very time consuming, but can be carried out in
parallel. Note that the optimal value of <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> will be
different if the nature of the problem (priors, order of the smoothness
constraint, etc) changes. We shall not concern ourselves with crossvalidaiton
here, and will use the optimal values from the paper.</p>
<p>For comparison purposes, we will also solve each observation independently,
which is similar to what one would do in look-up table-based inversion
approaches. In general, the problem of inverting six parameters from
a single multispectral observation is incredibly ill-posed. The very
informative sampling scheme of the MSI2 sensor however allows inversions.
We shall also calculate the associated uncertainty of these single
inversions, which we expect to be very high (and exhibit large degrees
of correlation between parameters), and also note that when no
observations are available, there will be no estimate of land surface
parameters.</p>
<p>The next sections describe the python <a class="reference external" href="https://github.com/jgomezdans/eoldas_release/blob/master/sentinel.py">script</a>
that performs the experiment.</p>
<div class="section" id="anatomy-of-the-simulation-code">
<h2>Anatomy of the simulation code<a class="headerlink" href="#anatomy-of-the-simulation-code" title="Permalink to this headline">¶</a></h2>
<p>The code is organised in a single class, <tt class="docutils literal"><span class="pre">Sentinel</span></tt>. This class will
perform all the above described tasks. The user might want to modify
this class to perform other experiments. The class basically writes
out files, and also runs the eoldas prototype as required. As mentioned
above, we use the <a class="reference external" href="http://rhodesmill.org/pyephem/">pyephem</a> package
to simulate the solar geometry.</p>
</div>
<div class="section" id="generating-the-synthetic-observations">
<h2>Generating the synthetic observations<a class="headerlink" href="#generating-the-synthetic-observations" title="Permalink to this headline">¶</a></h2>
<p>The code for this is fairly simple, and can be seen in the <tt class="docutils literal"><span class="pre">main</span></tt>
function in <tt class="docutils literal"><span class="pre">sentinel.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>  <span class="n">s</span> <span class="o">=</span> <span class="n">Sentinel</span><span class="p">()</span>
  <span class="c"># generate parameter dataset</span>
  <span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">366</span><span class="p">),</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">)</span>
  <span class="c"># generate noise free observations (every 5 days)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">fwdModel</span><span class="p">(</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">,</span><span class="s">&#39;input/sentinelClean.dat&#39;</span><span class="p">,</span><span class="n">every</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">fwdModel</span><span class="p">(</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">,</span><span class="s">&#39;input/sentinelGapClean.dat&#39;</span><span class="p">,</span><span class="n">every</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">prop</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">WINDOW</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
  <span class="c"># add noise to the observations</span>
  <span class="n">s</span><span class="o">.</span><span class="n">addNoiseToObservations</span><span class="p">(</span><span class="s">&#39;input/sentinelClean.dat&#39;</span><span class="p">,</span><span class="s">&#39;input/sentinel.dat&#39;</span><span class="p">,</span><span class="n">nMag</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">addNoiseToObservations</span><span class="p">(</span><span class="s">&#39;input/sentinelGapClean.dat&#39;</span><span class="p">,</span><span class="s">&#39;input/sentinelGap.dat&#39;</span><span class="p">,</span><span class="n">nMag</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>We first instantiate the <tt class="docutils literal"><span class="pre">Sentinel</span></tt> class, calculate the parameter
temporal trajectories using the <tt class="docutils literal"><span class="pre">Sentinel.parameters</span></tt> method. This
requires a time axis as well as an output file (in this case,
<tt class="docutils literal"><span class="pre">input/truth.dat</span></tt>. This file can also be used to compare inversion
results etc.). Once the parameter trajectories have been established,
we can forward model them to surface reflectance using the <tt class="docutils literal"><span class="pre">Sentinel.fwdModel</span></tt>
method. This method has a number of options that are important to note:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">ifile</span></tt></dt>
<dd>input data (parameters) file</dd>
<dt><tt class="docutils literal"><span class="pre">ofile</span></tt></dt>
<dd>output reflectance data file</dd>
<dt><tt class="docutils literal"><span class="pre">lat</span></tt></dt>
<dd>latitude (default &#8216;50:0&#8217;) (see ephem)</dd>
<dt><tt class="docutils literal"><span class="pre">lon</span></tt></dt>
<dd>longitude (default &#8216;&#8216;0:0&#8217;) (see ephem)</dd>
<dt><tt class="docutils literal"><span class="pre">year</span></tt></dt>
<dd>as int or string (default &#8216;2011&#8217;)</dd>
<dt><tt class="docutils literal"><span class="pre">maxVza</span></tt></dt>
<dd>maximum view zenith angle assumed (15 degrees default)</dd>
<dt><tt class="docutils literal"><span class="pre">minSD</span></tt></dt>
<dd>minimum noise</dd>
<dt><tt class="docutils literal"><span class="pre">maxSD</span></tt></dt>
<dd>maximum noise. The uncertainty in each waveband is scaled linearly with wavelength between minSD and maxSD</dd>
<dt><tt class="docutils literal"><span class="pre">fullBand</span></tt></dt>
<dd>set True if you want full band pass else False (default False). Note that its much slower to set this True.</dd>
<dt><tt class="docutils literal"><span class="pre">confFile</span></tt></dt>
<dd>configuration file (default <tt class="docutils literal"><span class="pre">config_files/sentinel0.conf</span></tt>). If this file doesnt exist, it will be generated from <tt class="docutils literal"><span class="pre">self.confTxt</span></tt>. If that doesn&#8217;t exist, <tt class="docutils literal"><span class="pre">self.generateConfTxt()</span></tt>  is invoked to provide a default.</dd>
<dt><tt class="docutils literal"><span class="pre">every</span></tt></dt>
<dd>sample output every &#8216;every&#8217; doys (default 5)</dd>
<dt><tt class="docutils literal"><span class="pre">prop</span></tt></dt>
<dd>proportion of clear sample days (default 1.0)</dd>
<dt><tt class="docutils literal"><span class="pre">WINDOW</span></tt></dt>
<dd>size of smoothing kernel to induce temporal correlation in data gaps if prop &lt; 1</dd>
</dl>
<p>Note that some other settings (such as default parameter values, and
which parameters will be varied temporally) are set in the class
constructor. In this case, we run the forward model twice, to create
two distinct datasets: a complete best-case scenario, and a second
scenario where the missing observations (with a proportion of 0.5 missing
observations). These two datafiles are &#8220;clean&#8221;, i.e., there&#8217;s no noise.
The <tt class="docutils literal"><span class="pre">Sentinel.addNoiseToObservations</span></tt> adds Gaussian independent noise
to the observations. The variance of the  noise is estipulated in the
header of the clean data file (a linear increase of uncertainty with
wavelength).</p>
</div>
<div class="section" id="solving-each-data-individually">
<h2>Solving each data individually<a class="headerlink" href="#solving-each-data-individually" title="Permalink to this headline">¶</a></h2>
<p>This part of the code will solve for each observation individually:
assuming some prior knowledge, we solve for the weighted least squares
fit. Mathematically, this for each observation <img class="math" src="_images/math/6c382eeb0dad017400c2bb6e32c2d5bdf4002c3e.png" alt="\mathbf{y}"/>, we
minimise the functional <img class="math" src="_images/math/02d945b2ad3726d4cd04e23514450581f231d909.png" alt="J(\mathbf{x})"/>, where <img class="math" src="_images/math/5f61118f2ae912f86e683687c005145b5eb54aec.png" alt="\mathbf{x}"/>
is the state tht describes that observation.</p>
<div class="math">
<p><img src="_images/math/2bae6539575b2105ac6b1c82cd388d4488d5822f.png" alt="J(\mathbf{x}) = \left(\mathbf{x}-\mathbf{x}_{p}\right)^{T}\mathbf{C}^{-1}_{prior}\left(\mathbf{x}-\mathbf{x}_{p}\right) + \left(H(\mathbf{x})-\mathbf{y}\right)^{T}\mathbf{C}^{-1}_{obs}\left(H(\mathbf{x})-\mathbf{y}\right)"/></p>
</div><p>Solving for single observations is a very hard problem: there usually
isn&#8217;t an unique solution as parameter compensate for each other, and
the observational constraint does not have enough information to allow
this. This is made even worse by additional noise. In consequence, the
shape of <img class="math" src="_images/math/02d945b2ad3726d4cd04e23514450581f231d909.png" alt="J(\mathbf{x})"/> is very flat over large areas, showing
no strong preference for values of the state vector. As a first test,
we can use the noise-free synthetic observations and invert them using
some kind of gradient descent algorithm that minimises <img class="math" src="_images/math/02d945b2ad3726d4cd04e23514450581f231d909.png" alt="J(\mathbf{x})"/>.
To make it faster, we can start the gradient descent algorithm with the
true values, and then calculate the Hessian and its inverse and look at
uncertainties in retrieved parameters. This is quite instructive in its
own right. A second test would be start the minimisation at some other
point that it&#8217;s not the true state, and see how the solution compares.
Finally, we&#8217;d want to invert each individual observation, taking into
account the noise.</p>
<p>We test some of these ideas with the clean datasets
(those that have had no noise added to them). We also plot the results
using graphical methods <tt class="docutils literal"><span class="pre">Sentinel.crossPlot</span></tt> and <tt class="docutils literal"><span class="pre">Sentinel.paramPlot</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>  <span class="c"># solve for parameter estimate, using one date at a time</span>
  <span class="c"># e.g. test for clean data starting from the correct value</span>
  <span class="c"># This should work perfectly &amp; go stright to the the solution</span>
  <span class="c"># So, this is a sanity check for the solver mainly, but it is also</span>
  <span class="c"># interesting to look at the distribution of uncertainties</span>
  <span class="c"># in the plot plots/sentinelClean1_pplot.png</span>
  <span class="c"># When we add noise, we expect the solution to lie somewhere in these bounds</span>
  <span class="c"># generally.</span>
  <span class="n">s</span><span class="o">.</span><span class="n">solveSingle</span><span class="p">(</span><span class="s">&#39;input/sentinelClean.dat&#39;</span><span class="p">,</span><span class="s">&#39;output/sentinelClean1.dat&#39;</span><span class="p">,</span><span class="n">initial</span><span class="o">=</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">crossPlot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">),</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;output/sentinelClean1.dat&#39;</span><span class="p">),</span>\
            <span class="n">params</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;plots/sentinelClean1_xplot.png&#39;</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">paramPlot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">),</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;output/sentinelClean1.dat&#39;</span><span class="p">),</span>\
            <span class="n">params</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;plots/sentinelClean1_pplot.png&#39;</span><span class="p">)</span>

  <span class="c"># e.g. test for clean data not starting from the correct value</span>
  <span class="c"># Ideally, this would provide the same result, but that is unlikely</span>
  <span class="c"># as the cost function is quite flat around the minimum.</span>
  <span class="c"># But actually it does a pretty good job other than perhaps the </span>
  <span class="c"># first sample, which suggests that we need to reconsider</span>
  <span class="c"># starting positions if we can afford it (e.g. go through the</span>
  <span class="c"># series backwards as well) </span>
  <span class="n">s</span><span class="o">.</span><span class="n">solveSingle</span><span class="p">(</span><span class="s">&#39;input/sentinelClean.dat&#39;</span><span class="p">,</span><span class="s">&#39;output/sentinelClean2.dat&#39;</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">crossPlot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">),</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;output/sentinelClean2.dat&#39;</span><span class="p">),</span>\
            <span class="n">params</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;plots/sentinelClean2_xplot.png&#39;</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">paramPlot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">),</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;output/sentinelClean2.dat&#39;</span><span class="p">),</span>\
            <span class="n">params</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;plots/sentinelClean2_pplot.png&#39;</span><span class="p">)</span>

  <span class="c"># e.g. test normal, i.e. data with noise. This is now a realistic test</span>
  <span class="c"># of the solver for noisy data. We expect the result to be similar</span>
  <span class="c"># to the truth (mostly within the 90% CI) </span>
  <span class="c"># Again, this should do a pretty decent job</span>
  <span class="n">s</span><span class="o">.</span><span class="n">solveSingle</span><span class="p">(</span><span class="s">&#39;input/sentinel.dat&#39;</span><span class="p">,</span><span class="s">&#39;output/sentinel.dat&#39;</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">crossPlot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">),</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;output/sentinel.dat&#39;</span><span class="p">),</span>\
            <span class="n">params</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;plots/sentinel_xplot.png&#39;</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">paramPlot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">),</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;output/sentinel.dat&#39;</span><span class="p">),</span>\
            <span class="n">params</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;plots/sentinel_pplot.png&#39;</span><span class="p">)</span>

  <span class="n">s</span><span class="o">.</span><span class="n">solveSingle</span><span class="p">(</span><span class="s">&#39;input/sentinelGap.dat&#39;</span><span class="p">,</span><span class="s">&#39;output/sentinelGap.dat&#39;</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">crossPlot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">),</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;output/sentinelGap.dat&#39;</span><span class="p">),</span>\
            <span class="n">params</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;plots/sentinelGap_xplot.png&#39;</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">paramPlot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;input/truth.dat&#39;</span><span class="p">),</span><span class="n">s</span><span class="o">.</span><span class="n">loadData</span><span class="p">(</span><span class="s">&#39;output/sentinelGap.dat&#39;</span><span class="p">),</span>\
            <span class="n">params</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;plots/sentinelGap_pplot.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure">
<img alt="_images/sentinelClean1.png" src="_images/sentinelClean1.png" style="width: 90%;" />
<p class="caption">Inverting each individual observation (no noise) starting from the true solution.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
<div class="figure">
<img alt="_images/sentinelClean2.png" src="_images/sentinelClean2.png" style="width: 90%;" />
<p class="caption">Inverting each individual observation (no noise) not specifying the true solution.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
<div class="figure">
<img alt="_images/sentinel.png" src="_images/sentinel.png" style="width: 90%;" />
<p class="caption">Inverting each individual noisy observation starting from the true solution. Complete series.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
<div class="figure">
<img alt="_images/sentinelGap.png" src="_images/sentinelGap.png" style="width: 90%;" />
<p class="caption">Inverting each individual noisy observation starting from the true solution. Gappy series.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
</div>
<div class="section" id="solving-using-data-assimilation">
<h2>Solving using data assimilation<a class="headerlink" href="#solving-using-data-assimilation" title="Permalink to this headline">¶</a></h2>
<p>Finally, we can solve the problem using the DA framework. This is done
using the <tt class="docutils literal"><span class="pre">Sentinel.solveRegular</span></tt> method. One way to speed up
processing is to start the inversion with the results calculated above
for the single observations.</p>
<div class="highlight-python"><div class="highlight"><pre>  <span class="c"># now, taking the result of the single inversion as the inital estimate (at the data points)</span>
  <span class="c"># try to solve for all time samples using regularisation</span>
  <span class="c"># If this takes some time, watch the world go by in the grpahs such as</span>
  <span class="c"># in output/sentinel_O_1_gamma_100_resul*.png</span>
  <span class="n">s</span><span class="o">.</span><span class="n">solveRegular</span><span class="p">(</span><span class="s">&#39;input/sentinel.dat&#39;</span><span class="p">,</span><span class="s">&#39;output/sentinel_O_1_gamma_150.dat&#39;</span><span class="p">,</span>\
            <span class="n">modelOrder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">gamma</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span><span class="n">initial</span><span class="o">=</span><span class="s">&#39;output/sentinel.dat&#39;</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">solveRegular</span><span class="p">(</span><span class="s">&#39;input/sentinelGap.dat&#39;</span><span class="p">,</span><span class="s">&#39;output/sentinelGap_O_1_gamma_150.dat&#39;</span><span class="p">,</span>\
            <span class="n">modelOrder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">gamma</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span><span class="n">initial</span><span class="o">=</span><span class="s">&#39;output/sentinelGap.dat&#39;</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">solveRegular</span><span class="p">(</span><span class="s">&#39;input/sentinel.dat&#39;</span><span class="p">,</span><span class="s">&#39;output/sentinel_O_2_gamma_530.dat&#39;</span><span class="p">,</span>\
            <span class="n">modelOrder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">gamma</span><span class="o">=</span><span class="mi">530</span><span class="p">,</span><span class="n">initial</span><span class="o">=</span><span class="s">&#39;output/sentinel.dat&#39;</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">solveRegular</span><span class="p">(</span><span class="s">&#39;input/sentinelGap.dat&#39;</span><span class="p">,</span><span class="s">&#39;output/sentinelGap_O_2_gamma_530.dat&#39;</span><span class="p">,</span>\
            <span class="n">modelOrder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">gamma</span><span class="o">=</span><span class="mi">530</span><span class="p">,</span><span class="n">initial</span><span class="o">=</span><span class="s">&#39;output/sentinelGap.dat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Here we need to put the solution plots. However, it appears that
we might need new <img class="math" src="_images/math/913e49ea63c6c130bb8d9d1c3556b052ecc404f8.png" alt="\Gamma"/> values?</p>
</div>
<div class="figure">
<img alt="_images/sentinel.png" src="_images/sentinel.png" style="width: 90%;" />
<p class="caption">Inverting each individual noisy observation starting from the true solution. Complete series.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
<div class="figure">
<img alt="_images/sentinelGap.png" src="_images/sentinelGap.png" style="width: 90%;" />
<p class="caption">Inverting each individual noisy observation starting from the true solution. Gappy series.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="example2.html">Radiative transfer modelling for optical remote sensing</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="example_spatial.html">Spatial and multi-scale data assimilation examples</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, P Lewis and J Gomez-Dans.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>