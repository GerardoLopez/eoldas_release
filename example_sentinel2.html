

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>A synthetic experiment: simulating the performance of Sentinel-2 &mdash; EOLDAS Users&#39; Guide 2012.06 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2012.06',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="EOLDAS Users&#39; Guide 2012.06 documentation" href="index.html" />
    <link rel="next" title="Inverting a time series of MODIS observations over agricultural fields" href="example_field.html" />
    <link rel="prev" title="Radiative transfer modelling for optical remote sensing" href="example2.html" /> 
  </head>
  <body>
      <div class="header">
        <a href="index.html">
          <img class="logo" src="_static/eoldas_logos.png" alt="Logo"/>
        </a>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="example2.html">Radiative transfer modelling for optical remote sensing</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="example_field.html">Inverting a time series of MODIS observations over agricultural fields</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="a-synthetic-experiment-simulating-the-performance-of-sentinel-2">
<h1>A synthetic experiment: simulating the performance of Sentinel-2<a class="headerlink" href="#a-synthetic-experiment-simulating-the-performance-of-sentinel-2" title="Permalink to this headline">¶</a></h1>
<p>A useful application of the EOLDAS tools is to simulate how different
sensors or combinations of sensors might be expected to work together.
Simply, we could generate a set of artificial observations, acquired
by a sensor (or sensors) from which the spectral, noise and orbital
acquisition characteristics are known (or we can try different set ups
to see their trade offs). We can then use EOLDAS to invert these
synthetic observations and compare to the reality that went into them.
This type of experiments can be very useful to test, for example, the
usefulness of constellation concepts. The current example is a
reduced version of the experiments that are presented in
<a class="reference external" href="http://dx.doi.org/10.1016/j.rse.2011.12.027">Lewis et al (2010)</a>, and
show the use of EOLDAS in simulating ESA&#8217;s upcoming Sentinel-2 performance
for the inversion of biophysical parameters. In this document, we try
to reproduce the middle column in Figure 2 in <a class="reference external" href="http://dx.doi.org/10.1016/j.rse.2011.12.027">Lewis et al (2010)</a></p>
<p>The experiment can be split into a set of simple tasks:</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>We need to generate an appropriate set of observations. On the one hand, this requires</dt>
<dd><ul class="first last simple">
<li>An idea of typical angular sampling.</li>
<li>An idea of the statistics of missing observations due to e.g. cloud.</li>
<li>Trajectories for the land surface parameters.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first"><em>Forward model</em> the land surface parameters to land surface reflectance.</p>
</li>
<li><p class="first">Add noise to the observations</p>
</li>
<li><p class="first">Invert the observations, with whatever prior information might be available.</p>
</li>
</ol>
<p>The first step will require the definition of a typical re-visit schedule
for the sensor, as well as information on illumination geometries. We
make use of the <a class="reference external" href="http://rhodesmill.org/pyephem/">pyephem</a> Python package to
calculate the solar position at a given latitude and longitude. Some
simple rules are given to model the sensor acquisition geometry (for
example, the view zenith angle is assumed to be random). We can use
full wavebands, or just the median wavelength of each band (the latter
is far more efficient, and this solution can be used as a starting
point to solve the full bandpass problem).</p>
<p>A further refinement is the inclusion of missing observations due to
cloud cover, for example. It is typically observed that cloudiness
is correlated in time, so a model of cloudiness that simulates the typical
burst nature of cloud statistics is required. Another way to go about this
is to use long term cloudiness observations, but we choose a very simple
approach in this work.</p>
<p>The parameter trajectories are functions that describe the evolution
of a given parameter in time. In this case, we choose to vary the following
parameters:</p>
<ul class="simple">
<li>LAI</li>
<li>Chlorophyll concentration</li>
<li>Leaf water</li>
<li>Leaf dry matter</li>
<li>Number of leaf layers</li>
<li>First soil component</li>
</ul>
<p>This is an ambitious scenario: the analytic trajectories chosen for these
parameters are smooth, but with very different degrees of smoothness. Some
parameters are set to be constant (leaf layers and leaf dry matter). We
will assume that the regulariser that solves this problem is identical
for all the parameters, and constant in time. Even though we know that
this is not the case, this simplifying assumption still allows the
recovery of reasonable parameter estimates. Note that while in some cases
(such as leaf area index) one might have mechanistic models that maybe
use meteorological inputs to simulate photosynthesis and allocation of
assimilated carbon to the leaves to estimate the amount of leaf area,
for other parameters that have a significant impact on the remote sensing
signal, these models might not be available.</p>
<p>The forward modelling of the parameter trajectories, coupled with the
required wavebands and illumination geometries, produces a set of
synthetic observations: this is what a sensor, operating with the given
characteristics would &#8220;see&#8221;, in terms of surface reflectance. As with
any measurement, noise needs to be incorporated. We do this by adding
some Gaussian noise to the simulated reflectances, in line with what
we expect to be typical values after atmospheric correction. Although
we assume noise to be uncorrelated across bands, in practice it will be.</p>
<p>Finally, we solve the inverse problem: find the parameter trajectories
given the set of noisy and incomplete observations. In reality, we also
need to estimate the strength of the regularisation, a hyperparameter.
In <a class="reference external" href="http://dx.doi.org/10.1016/j.rse.2011.12.027">Lewis et al (2011)</a>
this is done using cross-validation. In the paper, we proceeded as follows:</p>
<ol class="arabic">
<li><p class="first">Set a number of values that <span class="math">\(\Gamma\)</span> might take. This will necessarily be a large range (say from <span class="math">\(10^{-5}-10^{5}\)</span>), but prior experience might dictate a suitable interval.</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">For one value of <span class="math">\(\Gamma\)</span>...</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Select one single observation, and remove it from the observations that will go into the inversion</p>
<blockquote>
<div><ol class="arabic simple">
<li>Solve the inverse problem</li>
<li>Predict the missing observation, and compare with the truth</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Calculate a prediction metric, such as root mean square error (RMSE) or similar</p>
</li>
</ol>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Select the value of <span class="math">\(\Gamma\)</span> that results in the most accurate predictions.</p>
</li>
</ol>
<p>This method is clearly very time consuming, but can be carried out in
parallel. Note that the optimal value of <span class="math">\(\Gamma\)</span> will be
different if the nature of the problem (priors, order of the smoothness
constraint, etc) changes. We shall not concern ourselves with crossvalidaiton
here, and will use the optimal values from the paper.</p>
<p>For comparison purposes, we will also solve each observation independently,
which is similar to what one would do in look-up table-based inversion
approaches. In general, the problem of inverting six parameters from
a single multispectral observation is incredibly ill-posed. The very
informative sampling scheme of the MSI2 sensor however allows inversions.
We shall also calculate the associated uncertainty of these single
inversions, which we expect to be very high (and exhibit large degrees
of correlation between parameters), and also note that when no
observations are available, there will be no estimate of land surface
parameters.</p>
<p>The next sections describe the python <a class="reference external" href="https://github.com/jgomezdans/eoldas_release/blob/master/sentinel.py">script</a>
that performs the experiment.</p>
<div class="section" id="anatomy-of-the-simulation-code">
<h2>Anatomy of the simulation code<a class="headerlink" href="#anatomy-of-the-simulation-code" title="Permalink to this headline">¶</a></h2>
<p>The code is organised in a single class, <tt class="docutils literal"><span class="pre">Sentinel</span></tt>. This class will
perform all the above described tasks. The user might want to modify
this class to perform other experiments. The class basically writes
out files, and also runs the eoldas prototype as required. As mentioned
above, we use the <a class="reference external" href="http://rhodesmill.org/pyephem/">pyephem</a> package
to simulate the solar geometry.</p>
</div>
<div class="section" id="generating-the-synthetic-observations">
<h2>Generating the synthetic observations<a class="headerlink" href="#generating-the-synthetic-observations" title="Permalink to this headline">¶</a></h2>
<p>The code for this is fairly simple, and can be seen in the <tt class="docutils literal"><span class="pre">main</span></tt>
function in <tt class="docutils literal"><span class="pre">sentinel.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">lad</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">5</span> 


<span class="p">[</span><span class="n">general</span><span class="p">]</span>
<span class="n">is_spectral</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">calc_posterior_unc</span><span class="o">=</span><span class="bp">True</span>
<span class="n">help_calc_posterior_unc</span><span class="o">=</span><span class="s">&quot;Posterior uncertainty calculations&quot;</span>
<span class="n">write_results</span><span class="o">=</span><span class="bp">True</span>
<span class="n">doplot</span><span class="o">=</span><span class="bp">True</span>
</pre></div>
</div>
<p>We first instantiate the <tt class="docutils literal"><span class="pre">Sentinel</span></tt> class, calculate the parameter
temporal trajectories using the <tt class="docutils literal"><span class="pre">Sentinel.parameters</span></tt> method. This
requires a time axis as well as an output file (in this case,
<tt class="docutils literal"><span class="pre">input/truth.dat</span></tt>. This file can also be used to compare inversion
results etc.). Once the parameter trajectories have been established,
we can forward model them to surface reflectance using the <tt class="docutils literal"><span class="pre">Sentinel.fwdModel</span></tt>
method. This method has a number of options that are important to note:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">ifile</span></tt></dt>
<dd>input data (parameters) file</dd>
<dt><tt class="docutils literal"><span class="pre">ofile</span></tt></dt>
<dd>output reflectance data file</dd>
<dt><tt class="docutils literal"><span class="pre">lat</span></tt></dt>
<dd>latitude (default &#8216;50:0&#8217;) (see ephem)</dd>
<dt><tt class="docutils literal"><span class="pre">lon</span></tt></dt>
<dd>longitude (default &#8216;&#8216;0:0&#8217;) (see ephem)</dd>
<dt><tt class="docutils literal"><span class="pre">year</span></tt></dt>
<dd>as int or string (default &#8216;2011&#8217;)</dd>
<dt><tt class="docutils literal"><span class="pre">maxVza</span></tt></dt>
<dd>maximum view zenith angle assumed (15 degrees default)</dd>
<dt><tt class="docutils literal"><span class="pre">minSD</span></tt></dt>
<dd>minimum noise</dd>
<dt><tt class="docutils literal"><span class="pre">maxSD</span></tt></dt>
<dd>maximum noise. The uncertainty in each waveband is scaled linearly with wavelength between minSD and maxSD</dd>
<dt><tt class="docutils literal"><span class="pre">fullBand</span></tt></dt>
<dd>set True if you want full band pass else False (default False). Note that its much slower to set this True.</dd>
<dt><tt class="docutils literal"><span class="pre">confFile</span></tt></dt>
<dd>configuration file (default <tt class="docutils literal"><span class="pre">config_files/sentinel0.conf</span></tt>). If this file doesnt exist, it will be generated from <tt class="docutils literal"><span class="pre">self.confTxt</span></tt>. If that doesn&#8217;t exist, <tt class="docutils literal"><span class="pre">self.generateConfTxt()</span></tt>  is invoked to provide a default.</dd>
<dt><tt class="docutils literal"><span class="pre">every</span></tt></dt>
<dd>sample output every &#8216;every&#8217; doys (default 5)</dd>
<dt><tt class="docutils literal"><span class="pre">prop</span></tt></dt>
<dd>proportion of clear sample days (default 1.0)</dd>
<dt><tt class="docutils literal"><span class="pre">WINDOW</span></tt></dt>
<dd>size of smoothing kernel to induce temporal correlation in data gaps if prop &lt; 1</dd>
</dl>
<p>Note that some other settings (such as default parameter values, and
which parameters will be varied temporally) are set in the class
constructor. In this case, we run the forward model twice, to create
two distinct datasets: a complete best-case scenario, and a second
scenario where the missing observations (with a proportion of 0.5 missing
observations). These two datafiles are &#8220;clean&#8221;, i.e., there&#8217;s no noise.
The <tt class="docutils literal"><span class="pre">Sentinel.addNoiseToObservations</span></tt> adds Gaussian independent noise
to the observations. The variance of the  noise is estipulated in the
header of the clean data file (a linear increase of uncertainty with
wavelength).</p>
</div>
<div class="section" id="solving-each-data-individually">
<h2>Solving each data individually<a class="headerlink" href="#solving-each-data-individually" title="Permalink to this headline">¶</a></h2>
<p>This part of the code will solve for each observation individually:
assuming some prior knowledge, we solve for the weighted least squares
fit. Mathematically, this for each observation <span class="math">\(\mathbf{y}\)</span>, we
minimise the functional <span class="math">\(J(\mathbf{x})\)</span>, where <span class="math">\(\mathbf{x}\)</span>
is the state tht describes that observation.</p>
<div class="math">
\[J(\mathbf{x}) = \left(\mathbf{x}-\mathbf{x}_{p}\right)^{T}\mathbf{C}^{-1}_{prior}\left(\mathbf{x}-\mathbf{x}_{p}\right) + \left(H(\mathbf{x})-\mathbf{y}\right)^{T}\mathbf{C}^{-1}_{obs}\left(H(\mathbf{x})-\mathbf{y}\right)\]</div>
<p>Solving for single observations is a very hard problem: there usually
isn&#8217;t an unique solution as parameter compensate for each other, and
the observational constraint does not have enough information to allow
this. This is made even worse by additional noise. In consequence, the
shape of <span class="math">\(J(\mathbf{x})\)</span> is very flat over large areas, showing
no strong preference for values of the state vector. As a first test,
we can use the noise-free synthetic observations and invert them using
some kind of gradient descent algorithm that minimises <span class="math">\(J(\mathbf{x})\)</span>.
To make it faster, we can start the gradient descent algorithm with the
true values, and then calculate the Hessian and its inverse and look at
uncertainties in retrieved parameters. This is quite instructive in its
own right. A second test would be start the minimisation at some other
point that it&#8217;s not the true state, and see how the solution compares.
Finally, we&#8217;d want to invert each individual observation, taking into
account the noise.</p>
<p>We test some of these ideas with the clean datasets
(those that have had no noise added to them). We also plot the results
using graphical methods <tt class="docutils literal"><span class="pre">Sentinel.crossPlot</span></tt> and <tt class="docutils literal"><span class="pre">Sentinel.paramPlot</span></tt>.</p>
<div class="highlight-python"><pre>plotmod=30
help_plotmod='frequency of plotting'
plotmovie=False
epsilon=10e-15
help_epsilon="Epsilon"

[general.optimisation]
randomise=False

[operator]
prior.name=Operator
prior.datatypes = x,y
obs.name=Observation_Operator
obs.datatypes = x,y

[operator.prior.x]
names = $parameter.names[1:]
datatype = x

[operator.prior.y]
control = 'mask'.split()
names = $parameter.names[1:]
sd = [10.0]*len($operator.prior.y.names)
help_sd='set the prior sd'
datatype = y
state = $parameter.x.default[1:]
help_state = "Set the prior state vector"

[operator.prior.y.result]
filename='output/rse1/rse1_test_prior.dat'
help_filename = 'prior filename'

[operator.obs.rt_model]
model=semidiscrete1
use_median=True
help_use_median = "Flag to state whether full bandpass function should be used or not. If True, then the median wavelength of the bandpass function is used"
bounds = [400,2500,1]
help_bounds = "The spectral bounds (min,max,step) for the operator'
ignore_derivative=False
help_ignore_derivative = "Set to True to override loading any defined derivative functions in the library and use numerical approximations instead"

[operator.obs.x]
</pre>
</div>
<div class="figure">
<img alt="_images/sentinelClean1.png" src="_images/sentinelClean1.png" style="width: 90%;" />
<p class="caption">Inverting each individual observation (no noise) starting from the true solution.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
<div class="figure">
<img alt="_images/sentinelClean2.png" src="_images/sentinelClean2.png" style="width: 90%;" />
<p class="caption">Inverting each individual observation (no noise) not specifying the true solution.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
<div class="figure">
<img alt="_images/sentinel.png" src="_images/sentinel.png" style="width: 90%;" />
<p class="caption">Inverting each individual noisy observation starting from the true solution. Complete series.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
<div class="figure">
<img alt="_images/sentinelGap.png" src="_images/sentinelGap.png" style="width: 90%;" />
<p class="caption">Inverting each individual noisy observation starting from the true solution. Gappy series.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
</div>
<div class="section" id="solving-using-data-assimilation">
<h2>Solving using data assimilation<a class="headerlink" href="#solving-using-data-assimilation" title="Permalink to this headline">¶</a></h2>
<p>Finally, we can solve the problem using the DA framework. This is done
using the <tt class="docutils literal"><span class="pre">Sentinel.solveRegular</span></tt> method. One way to speed up
processing is to start the inversion with the results calculated above
for the single observations.</p>
<div class="highlight-python"><pre>sd = [1.0]*len($operator.obs.x.names)
datatype = x

[operator.obs.y]
control = 'mask vza vaa sza saa'.split()
names = ['433-453','457.5-522.5','542.5-577.5','650-680','697.5-712.5','732.5-747.5','773-793','784.5-899.5','855-875','935-955','1565-1655','2100-2280']
sd = ["0.004", "0.00416142",  "0.00440183", "0.00476245", "0.00489983", "0.00502003","0.00516772", "0.00537035", "0.00544934", "0.0057241", "0.00800801","0.01" ]
datatype = y
state = 'data/rse1_test.100.dat'
help_state='set the obs state file'

[operator.obs.y.result]
</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Here we need to put the solution plots. However, it appears that
we might need new <span class="math">\(\Gamma\)</span> values?</p>
</div>
<div class="figure">
<img alt="_images/sentinel.png" src="_images/sentinel.png" style="width: 90%;" />
<p class="caption">Inverting each individual noisy observation starting from the true solution. Complete series.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
<div class="figure">
<img alt="_images/sentinelGap.png" src="_images/sentinelGap.png" style="width: 90%;" />
<p class="caption">Inverting each individual noisy observation starting from the true solution. Gappy series.
Left panel: (transformed) parameters and 95% CI
Right panel: scatterplot of retrieved parameters vs true parameters.</p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="example2.html">Radiative transfer modelling for optical remote sensing</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="example_field.html">Inverting a time series of MODIS observations over agricultural fields</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, P Lewis and J Gomez-Dans.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>